<!doctype html>

<html>

    <head>
        <meta charset="utf-8">
        <title>Re.Photos Demo</title>
    </head>

    <body>
        <div id="leftC" style="float: left; width: 58%;">
            <canvas id="canvas" style="border:1px solid #d3d3d3;" 
                onmousedown="mouse_action(event, 1)" 
                onmouseup="mouse_action(event, -1)"
                onmousemove="mouse_action(event, 0)">
            </canvas>   
        </div>
        <div id="rightC" style="float: right; width: 38%;">
            <canvas id="canvasMag" style="border:1px solid #d3d3d3;">
            </canvas>   
            <div class="slidecontainer">
                <p>Alpha: <span id="alphaV"></span></p>
                <input style="width: 80%;" type="range" min="0" max="1" value=".5" class="slider" 
                       id="alphaRange" step=".01">
                <p>Red Green Toning: <span id="rgtV"></span></p>
                <input style="width: 80%;" type="range" min="0.0" max="1" value="1" class="slider" 
                       id="rgtRange" step=".01">
            </div>
            
            <div>
                <button type="button" id="resetBtn" onclick="reset()">Reset</button>   
            </div>
        </div>

        <script>
            // PARAMS
            const maxX = 2000;
            const maxMagWidth = 300;
            const img1Name = "marien1.jpg";
            const img2Name = "marien2.jpg";
            const col1 = 'rgb(255, 255, 0)';
            const col2 = 'rgb(0, 0, 255)';
            const mouseScale = 0.25;
        </script>

        <script src="glfx.js"></script>

        <script src="./gl-matrix.js"></script>

        <script src="./numeric.js"></script>

        <script>
            var canvas = document.getElementById("canvas");
            var leftCWidth = Math.min(maxX, 
                document.getElementById("leftC").clientWidth);
            var rightCWidth = Math.min(maxMagWidth, 
                document.getElementById("rightC").clientWidth);
            var canvasMag = document.getElementById("canvasMag");
            var canvasImg1;
            var canvasImg2;
            var aRange = document.getElementById("alphaRange"); 
            var sRange = document.getElementById("scaleRange"); 
            var img1 = new Image();
            var img2 = new Image();
            var texture1, texture2, maxY, ctx, ctxMag; 

            var cornerPoints = [];
            // array of points selected by mouse; first entry: image 1, second
            // entry: image 2, third entry: iamge 1, ...
            var points = [];
            var pointsTrans = [];

            var mat = mat3.create();
            var matPhase1 = mat3.create();
            var matPhase0 = mat3.create();


            function appMat () {
                var i;
                var matI = mat3.invert(mat3.create(), mat);
                for (i = 1; i < pointsTrans.length; i+=2) {
                    vec2.transformMat3(pointsTrans[i], pointsTrans[i], matI);
                }
            }

            function appRgt (img, v) {
                img.curves([[0,0], [.5,.5+v], [1,1]],
                       [[0,0], [.5,.5-v], [1,1]],
                       [[0,0], [.5,.5-v], [1,1]]);
            }   


            function drawMagni(x, y) {
                var img;
                ctxMag.clearRect(0,0,img1.width, img1.height);

                if (points.length == 8) {
                    var z = canvasImg1.width/20; 
                    ctxMag.drawImage(canvasImg1,x-z, y-z, 2*z, 2*z, 0,0,canvasMag.width, canvasMag.height);
                    ctxMag.globalAlpha= alpha;
                    ctxMag.drawImage(canvasImg2,x-z, y-z, 2*z, 2*z, 0,0,canvasMag.width, canvasMag.height);
                    ctxMag.globalAlpha= 1;
                } else if (points.length % 2 == 1) {
                    var z = canvasImg1.width/20; 
                    ctxMag.strokeStyle = col2;
                    ctxMag.drawImage(canvasImg1,x-z, y-z, 2*z, 2*z, 0,0,canvasMag.width, canvasMag.height);
                } else {
                    var z = canvasImg2.width/20; 
                    ctxMag.strokeStyle = col1;
                    ctxMag.drawImage(canvasImg2,x-z, y-z, 2*z, 2*z, 0,0,canvasMag.width, canvasMag.height);
                }

                ctxMag.lineWidth = 3;
                ctxMag.beginPath();
                var c = [canvasMag.width/2, canvasMag.height/2];
                var dIn = 2;
                var dOut = 20;
                ctxMag.moveTo(c[0]-dIn, c[1]);
                ctxMag.lineTo(c[0]-dOut, c[1]);
                                            
                ctxMag.moveTo(c[0]+dIn, c[1]);
                ctxMag.lineTo(c[0]+dOut, c[1]);
                                            
                ctxMag.moveTo(c[0], c[1]-dIn);
                ctxMag.lineTo(c[0], c[1]-dOut);
                                            
                ctxMag.moveTo(c[0], c[1]+dIn);
                ctxMag.lineTo(c[0], c[1]+dOut);

                ctxMag.stroke();

                
            }


            function drawPoint(c, i) {
                var s;
                var start = 1;
                var end = 10;

                if (i) {
                    ctx.strokeStyle = col1;
                    s = 1;
                } else {
                    ctx.strokeStyle = col2;
                    s = -1;
                }
                    
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(c[0]+start*s, c[1]+start);
                ctx.lineTo(c[0]+end*s, c[1]+end);
                ctx.moveTo(c[0]+start*s, c[1]-start);
                ctx.lineTo(c[0]+end*s, c[1]-end);
                ctx.stroke();
            }
                
            

            function drawPoints() {
                var i;
                for (i = 0; i < points.length; i++) {
                    (i % 2 == 0) ? drawPoint(pointsTrans[i], true) : drawPoint(pointsTrans[i], false);
                }
            }
                
                
            function draw() {
                //var mat = mat3.mul(mat3.create(), matPhase1, matPhase0);
                ctx.clearRect(0,0,img1.width, img1.height);

                canvasImg1.draw(texture1).hueSaturation(0,-rgt);
                appRgt(canvasImg1, -rgt/2);
                canvasImg1.update();
                ctx.drawImage(canvasImg1,0,0, img1.width, img1.height);

                canvasImg2.draw(texture2).hueSaturation(0,-rgt);
                appRgt(canvasImg2, rgt/2);
                if (points.length < 8) {
                    canvasImg2.matrixWarp(mat, false, false).update();
                } else {
                    canvasImg2.perspective(
                        [points[0][0], points[0][1],
                        points[2][0], points[2][1],
                        points[4][0], points[4][1],
                        points[6][0], points[6][1]],
                        [points[1][0], points[1][1],
                        points[3][0], points[3][1],
                        points[5][0], points[5][1],
                        points[7][0], points[7][1]]).update();
                }

                ctx.globalAlpha= alpha;
                ctx.drawImage(canvasImg2, 0, 0, img2.width, img2.height);
                ctx.globalAlpha= 1;

                drawPoints();
            }
                
            img2.onload = function() {

                // Resize images
                maxY = leftCWidth *
                    Math.max(img1.height/img1.width, img2.height/img2.width);


                img1.width = leftCWidth;
                img1.height = maxY;
                img2.width = leftCWidth;
                img2.height = maxY;
                canvas.width = leftCWidth;
                canvas.height = maxY;
                
                ctx = canvas.getContext("2d");

                ctxMag = canvasMag.getContext("2d");
                canvasMag.width = rightCWidth;
                canvasMag.height = rightCWidth;



                // try to create a WebGL canvas (will fail if WebGL isn't supported)
                try {
                    canvasImg1 = fx.canvas();
                    texture1 = canvasImg1.texture(img1);
                    canvasImg2 = fx.canvas();
                    texture2 = canvasImg2.texture(img2);
                } catch (e) {
                    alert(e);
                    return;
                }

                reset();
            }

            
            img1.src = img1Name;
            img2.src = img2Name;


            // Alpha Slider
            var alphaV = document.getElementById("alphaV");
            var slider = document.getElementById("alphaRange");
            alphaV.innerHTML = slider.value; 
            var alpha = slider.value;
            slider.oninput = function() {
                alphaV.innerHTML = this.value;
                alpha = this.value;
                draw();
            }
            
            // Rgt Slider
            var rgtV = document.getElementById("rgtV");
            var slider = document.getElementById("rgtRange");
            rgtV.innerHTML = slider.value; 
            var rgt = slider.value;
            slider.oninput = function() {
                rgtV.innerHTML = this.value;
                rgt = this.value;
                draw();
            }


            // Phase 0: Translation
            function phase0 () {
                var diff;

                diff = vec2.sub(vec2.create(), points[0], points[1]);
                mat3.fromTranslation(matPhase0, diff);
                mat3.copy(mat, matPhase0);
                pointsTrans[0] = vec2.clone(pointsTrans[1]);
            }


            // Phase 1: Scaling and Rotation
            function phase1 () {
                var dist1, dist2, angle, v1, v2, a1, a2, vx;

                dist1 = vec2.dist(pointsTrans[0], pointsTrans[2]);
                dist2 = vec2.dist(pointsTrans[1], pointsTrans[3]);


                mat = mat3.create(); 
                mat3.translate(matPhase1, matPhase1, pointsTrans[0]);

                mat3.scale(matPhase1, matPhase1, 
                        vec2.fromValues(dist1/dist2, dist1/dist2));


                v1 = vec2.normalize(vec2.create(), vec2.sub(vec2.create(), pointsTrans[2], pointsTrans[0]));
                v2 = vec2.normalize(vec2.create(), vec2.sub(vec2.create(), pointsTrans[3], pointsTrans[1]));

                if (vec2.equals(v1, v2)) {
                    angle = 0;
                } else {
                    vx = vec2.fromValues(1,0);
                    a1 = Math.acos(vec2.dot(vx, v1));
                    a2 = Math.acos(vec2.dot(vx, v2));
                    a1 = (v1[1] > 0) ? Math.PI + (Math.PI - a1) : a1;
                    a2 = (v2[1] > 0) ? Math.PI + (Math.PI - a2) : a2;

                    angle = a2 - a1;
                    mat3.rotate(matPhase1, matPhase1, angle);
                }

                mat3.translate(matPhase1, matPhase1, 
                        vec2.scale(vec2.create(), pointsTrans[0], -1));

                mat3.mul(mat, matPhase0, matPhase1);
                pointsTrans[2] = vec2.clone(pointsTrans[3]);

           } 


            // Phase 2: Affine
            // Would only add shear which has no real application
            // Possible Perspective with computed fourth point:
            // Mirror forth point along perpendicular bisector 
            // of points 0/1 and points 2/3
            function phase2 () {
                points.push(points[4]);
                points.push(points[5]);
                //points.pop();
                //points.pop();
            }


            // Phase 3: Perspective
            function phase3 () {

                var i;
                var matI = mat3.invert(mat3.create(), matPhase0);
                vec2.transformMat3(points[2], points[2], matPhase0);
                for (i = 4; i < 8; i+=2) {
                    vec2.transformMat3(points[i], points[i], mat);
                }

                pointsTrans[4] = vec2.clone(pointsTrans[5]);
                pointsTrans[6] = vec2.clone(pointsTrans[7]);
            }
                

            function getNIdx (mp) {
                var i, dist, nIdx;
                var min = Infinity;

                for (i=0; i < 8; i+=2) {
                    dist = vec2.dist(mp, points[i]);
                    if (dist < min) {
                        min = dist;
                        nIdx = i;
                    }
                }
                console.log(min);
                console.log(dist);
                
                return nIdx;
            }
                
            
            // mouse funcionality
            var mouseDown = false;
            var mousePosOld = null;
            var marking = true;
            var nIdx = -1;
            function getMousePos(canvas, evt) {
                var rect = canvas.getBoundingClientRect();
                return vec2.fromValues((evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,
                    (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height);
            }
            function mouse_action(event, clicked) {
                var mousePos = getMousePos(canvas, event);

                if (clicked == 1) {
                    mouseDown = true;
                    mousePosOld = getMousePos(canvas, event); 
                    if (marking) {
                        points.push(mousePos);
                        pointsTrans.push(vec2.clone(mousePos));
                        if (points.length == 2) {
                            phase0();
                        } else if (points.length == 4) {
                            phase1();
                        } else if (points.length == 6) {
                    //        phase2();
                        } else if (points.length == 8 && marking) {
                            marking = false;
                            phase3();
                        }
                        draw()
                    } else {
                        nIdx = getNIdx(mousePos);
                    }
                } else if ( clicked == 0 ) {
                    drawMagni(mousePos[0], mousePos[1]);
                    if (!marking && mouseDown) {
                        var diff = vec2.sub(vec2.create(), mousePosOld, mousePos);
                        vec2.scale(diff, diff, mouseScale);
                        console.log(nIdx);
                        vec2.add(points[nIdx], points[nIdx], diff);
                        vec2.add(pointsTrans[nIdx], pointsTrans[nIdx], vec2.scale(vec2.create(), diff, -1));
                        mousePosOld = vec2.clone(mousePos);
                        draw()
                    }
                } else if ( clicked == -1) {
                    mouseDown = false;
                }
            }



            
            // resset 
            function reset() {
                marking = true;
                pointsTrans = [];
                points = [];
                mat = mat3.create();
                matPhase0 = mat3.create();
                matPhase1 = mat3.create();
                draw();
            }
                



        </script>
    </body>

</html>
