
//                    } else if (phase == 2) {
//                        if (points.length == 4) {
//                            points.push(mousePos);
//                        } else if (points.length == 5) {
//                            points.push(mousePos);
//                            phase++;
//                            console.log('affine');
//
//                            
////                            var a = [[points[0][0], points[0][1], 1,],
////                                     [points[2][0], points[2][1], 1,],
////                                     [points[4][0], points[4][1], 1,]];
//                            var a = [[points[0][0], points[2][0], points[4][0]],
//                                     [points[0][1], points[2][1], points[4][1]],
//                                     [1,1,1]];
//                            var inv = numeric.inv(a);
//
//                            
//                            var b = [[points[1][0], points[3][0], points[5][0]],
//                                     [points[1][1], points[3][1], points[5][1]]];
//
//                            console.log('a');
//                            console.log(a);
//                            console.log('inv');
//                            console.log(inv);
//
//                            console.log('ident');
//                            console.log(numeric.dot(a, inv));
//
//                            var p = numeric.dot(b, inv);
//                            console.log(p);
//                            var mat = mat2d.fromValues(p[0][0],p[0][1],p[0][2],p[1][0],p[1][1],p[1][2]);
//                            console.log('mat');
//                            console.log(mat);
//
//                            console.log('corners');
//                            console.log(cornerPoints);
////                            for (var i = 0; i < cornerPoints.length; i++) {
////                                vec2.transformMat2d(cornerPoints[i], cornerPoints[i], mat);
////                            }   
////                            console.log('corners');
////                            console.log(cornerPoints);
//////
//                            vec2.transformMat2d(points[5], points[5], mat);
//                            draw();
//                            brea = true;
//
////                            console.log('a');
////                            console.log(a);
////                            console.log('b');
////                            console.log(b);
////
////                            console.log(inv);
////                            console.log('p');
////                            console.log(p);
//
//
//
//                        }
                    } 





                //if (mouseDown) {
                //    var mousePos = vec2.fromValues(event.clientX, event.clientY);
                //    //console.log(mousePos);
                //    // check if mouse movement is at least one pixel of canvas
                //        if (!brea  && phase >= 3) {            
                //        if (!vec2.equals(mousePos, mousePosOld)) {
                //            var diff = vec2.sub(vec2.create(), mousePos, mousePosOld);

                //            // check wich quadrant
                //            console.log(cornerPoints);
                //            console.log(diff);
                //            if (mousePos[0] < canvas.width/2 || true){
                //                if (mousePos[1] < canvas.height/2 || true) {
                //                    
//
//              //                      // perspective
//              //                      var c = vec2.fromValues(Math.abs((points[0][0] - points[2][0])/2), Math.abs((points[0][1] - points[2][1])/2));
//              //                      var c = vec2.fromValues(500,500);
//              //                      
//
//              //                      //cOld[0]+= (cOld[0] -mousePosOld[0]);
//              //                      //cOld[1] = mousePosOld[1];
//              //                      
//              //                      var p4Old = vec2.clone(c);
//              //                      var p4 = vec2.clone(c);
//
//
//
//              //                      console.log(mousePos);
//
////            //                        var ro1 = [mousePosOld[0], points[0][0], points[2][0]];
////            //                        var ro2 = [mousePosOld[1], points[0][1], points[2][1]];
////            //                        var ro3 = [1, 1, 1];
//              //                      var ro1 = [mousePosOld[0], mousePosOld[1], 1];
//              //                      var ro2 = [points[0][0], points[0][1],1];
//              //                      var ro3 = [points[2][0], points[2][1],1];
//              //                      var param1 = numeric.solve([ro1, ro2, ro3], [p4Old[0], p4Old[1], 1]);
//              //                      var A = mat3.fromValues(param1[0]*mousePosOld[0], param1[0]* mousePosOld[1], param1[0], param1[1]*points[0][0], param1[1]* points[0][1], param1[1], param1[2]*points[2][0], param1[2]* points[2][1], param1[2]);
//              //                      var AInv = mat3.create();
//              //                      mat3.invert(AInv, A);
//
//              //                      //var ro1B = [mousePos[0], points[0][0], points[2][0]];
//              //                      //var ro2B = [mousePos[1], points[0][1], points[2][1]];
//              //                      //var ro3B = [1, 1, 1];
//              //                      var ro1B = [mousePos[0], mousePos[1], 1];
//              //                      var ro2B = [points[0][0], points[0][1],1];
//              //                      var ro3B = [points[2][0], points[2][1],1];
//              //                      var param2 = numeric.solve([ro1B, ro2B, ro3B], [p4[0], p4[1], 1]);
//              //                      var B = mat3.fromValues(param2[0]*mousePos[0], param2[0]* mousePos[1], param2[0], param2[1]*points[0][0], param2[1]* points[0][1], param2[1], param2[2]*points[2][0], param2[2]* points[2][1], param2[2]);
//              //                      var BInv = mat3.create();
//              //                      mat3.invert(BInv, B);
//
//
//              //                      var C = mat3.create();
//              //                      mat3.mul(C, B, AInv);
//              //                      console.log(C);
//
//              //                      
////            //                        vec2.transformMat3(test, cornerPoints[2], B);
////            //                        console.log(test);
//
//
//              //                     // var v1 =V [mousePosStart[0], mousePosStart[1], 1];
//              //                     // var v2 = [points[0][0], points[0][1], 1];
//              //                     // var v3 = [points[2][0], points[2][1], 1];
//              //                     // var v4 = [cornerPoints[2][0], cornerPoints[2][1], 1];
//
//              //                     // console.log(v1, v2, v3, v4);
//              //                     // var r1 = numeric.solve([v1, v2, v3, v4],
//              //                     //                          [mousePos[0], points[0][0], points[2][0], cornerPoints[2][0]]);
//              //                     //                         
//              //                     // console.log(r1);
//              //                      for (var i = 0; i < cornerPoints.length; i++) {
//              //                          var v = vec3.fromValues(cornerPoints[i][0], cornerPoints[i][1], 1);
//
//              //                          vec3.transformMat3(v, v, C);
//
//              //                          vec3.scale(v, v, 1/v[2]);
//              //                          cornerPoints[i] = vec2.fromValues(v[0], v[1]);
//              //                      }   
//
                //                } else {
                //                    vec2.add(cornerPoints[3], cornerPoints[3], diff);
                //                }
                //            } else {
                //                if (mousePos[1] < canvas.height/2) {
                //                    vec2.add(cornerPoints[1], cornerPoints[1], diff);
                //                } else {
                //                    vec2.add(cornerPoints[2], cornerPoints[2], diff);
                //                }
                //            }
                //            
                //            draw();
                //            mousePosOld = mousePos;
                //        }
                //    }
                }
                brea = false;
            }
